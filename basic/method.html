<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>方法Method - Rust语言圣经(Rust学习教程)</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/ferris.css">
        <link rel="stylesheet" href="../assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about-book.html">Rust语言圣经</a></li><li class="chapter-item expanded affix "><a href="../into-rust.html">进入Rust编程世界</a></li><li class="chapter-item expanded "><a href="../first-try/intro.html"><strong aria-hidden="true">1.</strong> 寻找牛刀，以便小试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../first-try/installation.html"><strong aria-hidden="true">1.1.</strong> 安装Rust环境</a></li><li class="chapter-item expanded "><a href="../first-try/editor.html"><strong aria-hidden="true">1.2.</strong> 墙推VSCode!</a></li><li class="chapter-item expanded "><a href="../first-try/cargo.html"><strong aria-hidden="true">1.3.</strong> 认识Cargo</a></li><li class="chapter-item expanded "><a href="../first-try/hello-world.html"><strong aria-hidden="true">1.4.</strong> 不仅仅是Hello world</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/intro.html"><strong aria-hidden="true">2.</strong> Rust基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/variable.html"><strong aria-hidden="true">2.1.</strong> 变量绑定与解构</a></li><li class="chapter-item expanded "><a href="../basic/base-type/index.html"><strong aria-hidden="true">2.2.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/base-type/numbers.html"><strong aria-hidden="true">2.2.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="../basic/base-type/char-bool.html"><strong aria-hidden="true">2.2.2.</strong> 字符、布尔、元类型</a></li><li class="chapter-item "><a href="../basic/base-type/statement-expression.html"><strong aria-hidden="true">2.2.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="../basic/base-type/function.html"><strong aria-hidden="true">2.2.4.</strong> 函数</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/ownership/index.html"><strong aria-hidden="true">2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/ownership/ownership.html"><strong aria-hidden="true">2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="../basic/ownership/borrowing.html"><strong aria-hidden="true">2.3.2.</strong> 引用与借用</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/compound-type/intro.html"><strong aria-hidden="true">2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/compound-type/string-slice.html"><strong aria-hidden="true">2.4.1.</strong> 字符串与切片</a></li><li class="chapter-item "><a href="../basic/compound-type/tuple.html"><strong aria-hidden="true">2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="../basic/compound-type/struct.html"><strong aria-hidden="true">2.4.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../basic/compound-type/enum.html"><strong aria-hidden="true">2.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../basic/compound-type/array.html"><strong aria-hidden="true">2.4.5.</strong> 数组</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/flow-control.html"><strong aria-hidden="true">2.5.</strong> 流程控制</a></li><li class="chapter-item expanded "><a href="../basic/match-pattern/intro.html"><strong aria-hidden="true">2.6.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/match-pattern/match-if-let.html"><strong aria-hidden="true">2.6.1.</strong> match和if let</a></li><li class="chapter-item "><a href="../basic/match-pattern/option.html"><strong aria-hidden="true">2.6.2.</strong> 解构Option</a></li><li class="chapter-item "><a href="../basic/match-pattern/pattern-match.html"><strong aria-hidden="true">2.6.3.</strong> 模式适用场景</a></li><li class="chapter-item "><a href="../basic/match-pattern/all-patterns.html"><strong aria-hidden="true">2.6.4.</strong> 全模式列表</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/method.html" class="active"><strong aria-hidden="true">2.7.</strong> 方法Method</a></li><li class="chapter-item expanded "><a href="../basic/trait/intro.html"><strong aria-hidden="true">2.8.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/trait/generic.html"><strong aria-hidden="true">2.8.1.</strong> 泛型Generics</a></li><li class="chapter-item "><a href="../basic/trait/trait.html"><strong aria-hidden="true">2.8.2.</strong> 特征Trait</a></li><li class="chapter-item "><a href="../basic/trait/trait-object.html"><strong aria-hidden="true">2.8.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="../basic/trait/advance-trait.html"><strong aria-hidden="true">2.8.4.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/collections/intro.html"><strong aria-hidden="true">2.9.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/collections/vector.html"><strong aria-hidden="true">2.9.1.</strong> 动态数组Vector</a></li><li class="chapter-item "><a href="../basic/collections/hashmap.html"><strong aria-hidden="true">2.9.2.</strong> KV存储HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/converse.html"><strong aria-hidden="true">2.10.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="../basic/result-error/intro.html"><strong aria-hidden="true">2.11.</strong> 返回和错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../basic/result-error/panic.html"><strong aria-hidden="true">2.11.1.</strong> panic深入剖析!</a></li><li class="chapter-item "><a href="../basic/result-error/result.html"><strong aria-hidden="true">2.11.2.</strong> 返回值Result和?</a></li></ol></li><li class="chapter-item expanded "><a href="../basic/comment.html"><strong aria-hidden="true">2.12.</strong> 文档注释 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../advance/intro.html"><strong aria-hidden="true">3.</strong> Rust高级进阶 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advance/lifetime/intro.html"><strong aria-hidden="true">3.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/lifetime/basic.html"><strong aria-hidden="true">3.1.1.</strong> 认识生命周期</a></li><li class="chapter-item "><a href="../advance/lifetime/advance.html"><strong aria-hidden="true">3.1.2.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="../advance/hrtb.html"><strong aria-hidden="true">3.2.</strong> 高阶特征约束(HRTB) todo</a></li><li class="chapter-item expanded "><a href="../advance/functional-programing/intro.html"><strong aria-hidden="true">3.3.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/functional-programing/closure.html"><strong aria-hidden="true">3.3.1.</strong> 闭包closure</a></li><li class="chapter-item "><a href="../advance/functional-programing/iterator.html"><strong aria-hidden="true">3.3.2.</strong> 迭代器iterator</a></li></ol></li><li class="chapter-item expanded "><a href="../advance/crate-module/intro.html"><strong aria-hidden="true">3.4.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/crate-module/crate.html"><strong aria-hidden="true">3.4.1.</strong> 包crate</a></li><li class="chapter-item "><a href="../advance/crate-module/module.html"><strong aria-hidden="true">3.4.2.</strong> 模块Module</a></li><li class="chapter-item "><a href="../advance/crate-module/use.html"><strong aria-hidden="true">3.4.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item expanded "><a href="../advance/custom-type.html"><strong aria-hidden="true">3.5.</strong> 深入类型之newtype和Sized</a></li><li class="chapter-item expanded "><a href="../advance/formatted-output.html"><strong aria-hidden="true">3.6.</strong> 格式化输出</a></li><li class="chapter-item expanded "><a href="../advance/smart-pointer/intro.html"><strong aria-hidden="true">3.7.</strong> 智能指针 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/smart-pointer/box.html"><strong aria-hidden="true">3.7.1.</strong> Box对象(todo)</a></li><li class="chapter-item "><a href="../advance/smart-pointer/deref-drop.html"><strong aria-hidden="true">3.7.2.</strong> Deref和Drop特征(todo)</a></li><li class="chapter-item "><a href="../advance/smart-pointer/cell.html"><strong aria-hidden="true">3.7.3.</strong> Cell todo</a></li><li class="chapter-item "><a href="../advance/smart-pointer/rc-refcell.html"><strong aria-hidden="true">3.7.4.</strong> Rc与RefCell(todo)</a></li><li class="chapter-item "><a href="../advance/smart-pointer/self-referrence.html"><strong aria-hidden="true">3.7.5.</strong> 自引用与内存泄漏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../advance/global-variable.html"><strong aria-hidden="true">3.8.</strong> 全局变量 todo</a></li><li class="chapter-item expanded "><a href="../advance/multi-threads/intro.html"><strong aria-hidden="true">3.9.</strong> 多线程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../advance/multi-threads/thread.html"><strong aria-hidden="true">3.9.1.</strong> 线程管理(todo)</a></li><li class="chapter-item "><a href="../advance/multi-threads/message-passing.html"><strong aria-hidden="true">3.9.2.</strong> 消息传递(todo)</a></li><li class="chapter-item "><a href="../advance/multi-threads/ref-counter-lock.html"><strong aria-hidden="true">3.9.3.</strong> 数据共享Arc、Mutex、Rwlock(todo)</a></li><li class="chapter-item "><a href="../advance/multi-threads/races.html"><strong aria-hidden="true">3.9.4.</strong> 数据竞争(todo)</a></li><li class="chapter-item "><a href="../advance/multi-threads/send-sync.html"><strong aria-hidden="true">3.9.5.</strong> Send、Sync(todo)</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../pitfalls/index.html"><strong aria-hidden="true">4.</strong> Rust陷阱系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pitfalls/use-vec-in-for.html"><strong aria-hidden="true">4.1.</strong> for循环中使用外部数组</a></li><li class="chapter-item expanded "><a href="../pitfalls/stack-overflow.html"><strong aria-hidden="true">4.2.</strong> 线程类型导致的栈溢出</a></li><li class="chapter-item expanded "><a href="../pitfalls/arithmetic-overflow.html"><strong aria-hidden="true">4.3.</strong> 算术溢出导致的panic</a></li><li class="chapter-item expanded "><a href="../pitfalls/closure-with-lifetime.html"><strong aria-hidden="true">4.4.</strong> 闭包中奇怪的生命周期</a></li><li class="chapter-item expanded "><a href="../pitfalls/the-disabled-mutability.html"><strong aria-hidden="true">4.5.</strong> 可变变量不可变？</a></li><li class="chapter-item expanded "><a href="../pitfalls/multiple-mutable-references.html"><strong aria-hidden="true">4.6.</strong> 可变借用失败引发的深入思考</a></li><li class="chapter-item expanded "><a href="../pitfalls/lazy-iterators.html"><strong aria-hidden="true">4.7.</strong> 不太勤快的迭代器</a></li></ol></li><li class="chapter-item expanded "><a href="../practice/intro.html"><strong aria-hidden="true">5.</strong> Rust最佳实践 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../practice/coding-tips.html"><strong aria-hidden="true">5.1.</strong> 一些写代码的技巧 todo</a></li><li class="chapter-item expanded "><a href="../practice/best-pratice.html"><strong aria-hidden="true">5.2.</strong> 最佳实践 todo</a></li></ol></li><li class="chapter-item expanded "><a href="../errors/intro.html"><strong aria-hidden="true">6.</strong> 错误处理 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../errors/simplify.html"><strong aria-hidden="true">6.1.</strong> 简化错误处理</a></li><li class="chapter-item expanded "><a href="../errors/user-define.html"><strong aria-hidden="true">6.2.</strong> 自定义错误</a></li><li class="chapter-item expanded "><a href="../errors/pretty-format.html"><strong aria-hidden="true">6.3.</strong> 让错误输出更优雅</a></li><li class="chapter-item expanded "><a href="../errors/panic-codes.html"><strong aria-hidden="true">6.4.</strong> 会导致panic的代码</a></li></ol></li><li class="chapter-item expanded "><a href="../test/intro.html"><strong aria-hidden="true">7.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../test/unit.html"><strong aria-hidden="true">7.1.</strong> 单元测试</a></li><li class="chapter-item expanded "><a href="../test/intergration.html"><strong aria-hidden="true">7.2.</strong> 集成测试</a></li><li class="chapter-item expanded "><a href="../test/benchmark.html"><strong aria-hidden="true">7.3.</strong> 性能测试</a></li><li class="chapter-item expanded "><a href="../test/ci.html"><strong aria-hidden="true">7.4.</strong> 持续集成</a></li></ol></li><li class="chapter-item expanded "><a href="../traits/intro.html"><strong aria-hidden="true">8.</strong> 常见特征解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../traits/from-into.html"><strong aria-hidden="true">8.1.</strong> 类型转换From/Into</a></li><li class="chapter-item expanded "><a href="../traits/as-ref-as-mut.html"><strong aria-hidden="true">8.2.</strong> AsRef, AsMut</a></li><li class="chapter-item expanded "><a href="../traits/borrow-family.html"><strong aria-hidden="true">8.3.</strong> Borrow, BorrowMut, ToOwned</a></li><li class="chapter-item expanded "><a href="../traits/deref.html"><strong aria-hidden="true">8.4.</strong> Deref和引用隐式转换</a></li><li class="chapter-item expanded "><a href="../traits/cow.html"><strong aria-hidden="true">8.5.</strong> 写时拷贝Cow</a></li><li class="chapter-item expanded "><a href="../traits/eq.html"><strong aria-hidden="true">8.6.</strong> Eq</a></li></ol></li><li class="chapter-item expanded "><a href="../memory/intro.html"><strong aria-hidden="true">9.</strong> 深入内存 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../memory/pointer-ref.html"><strong aria-hidden="true">9.1.</strong> 指针和引用(todo)</a></li><li class="chapter-item expanded "><a href="../memory/uninit.html"><strong aria-hidden="true">9.2.</strong> 未初始化内存(todo)</a></li><li class="chapter-item expanded "><a href="../memory/allocation.html"><strong aria-hidden="true">9.3.</strong> 内存分配(todo)</a></li><li class="chapter-item expanded "><a href="../memory/layout.html"><strong aria-hidden="true">9.4.</strong> 内存布局(todo)</a></li><li class="chapter-item expanded "><a href="../memory/virtual.html"><strong aria-hidden="true">9.5.</strong> 虚拟内存(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../networking/intro.html"><strong aria-hidden="true">10.</strong> 网络和异步编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../networking/tcp.html"><strong aria-hidden="true">10.1.</strong> TCP和网络原理(todo)</a></li><li class="chapter-item expanded "><a href="../networking/concurrency-parallelism.html"><strong aria-hidden="true">10.2.</strong> 并发与并行(todo)</a></li><li class="chapter-item expanded "><a href="../networking/async/intro.html"><strong aria-hidden="true">10.3.</strong> 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../networking/async/async-await.html"><strong aria-hidden="true">10.3.1.</strong> async/await语法</a></li><li class="chapter-item "><a href="../networking/async/future/into.html"><strong aria-hidden="true">10.3.2.</strong> future详解</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../networking/async/future/future.html"><strong aria-hidden="true">10.3.2.1.</strong> 何为Future</a></li><li class="chapter-item "><a href="../networking/async/future/task-schedule.html"><strong aria-hidden="true">10.3.2.2.</strong> 任务调度</a></li><li class="chapter-item "><a href="../networking/async/future/task-excutor.html"><strong aria-hidden="true">10.3.2.3.</strong> 任务执行器</a></li><li class="chapter-item "><a href="../networking/async/future/system-io.html"><strong aria-hidden="true">10.3.2.4.</strong> 系统IO</a></li><li class="chapter-item "><a href="../networking/async/future/multi-futures.html"><strong aria-hidden="true">10.3.2.5.</strong> 执行多个Future</a></li></ol></li><li class="chapter-item "><a href="../networking/async/pin-unpin.html"><strong aria-hidden="true">10.3.3.</strong> Pin、Unpin(todo)</a></li><li class="chapter-item "><a href="../networking/async/future/workarounds.html"><strong aria-hidden="true">10.3.4.</strong> 遇到不支持的异步特性?</a></li><li class="chapter-item "><a href="../networking/async/http.html"><strong aria-hidden="true">10.3.5.</strong> HTTP Client/Server</a></li><li class="chapter-item "><a href="../networking/async/tokio/intro.html"><strong aria-hidden="true">10.3.6.</strong> 定海神针-tokio包</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../networking/async/tokio/basic.html"><strong aria-hidden="true">10.3.6.1.</strong> 基本用法</a></li><li class="chapter-item "><a href="../networking/async/tokio/stream.html"><strong aria-hidden="true">10.3.6.2.</strong> 异步消息流</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../style-guide/intro.html"><strong aria-hidden="true">11.</strong> 代码规范 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../style-guide/naming.html"><strong aria-hidden="true">11.1.</strong> 命名规范</a></li><li class="chapter-item expanded "><a href="../style-guide/code.html"><strong aria-hidden="true">11.2.</strong> 代码风格(todo)</a></li><li class="chapter-item expanded "><a href="../style-guide/mark.html"><strong aria-hidden="true">11.3.</strong> 代码标记</a></li><li class="chapter-item expanded "><a href="../style-guide/clippy.html"><strong aria-hidden="true">11.4.</strong> Clippy</a></li></ol></li><li class="chapter-item expanded "><a href="../object-oriented/intro.html"><strong aria-hidden="true">12.</strong> 面向对象 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../object-oriented/characteristics.html"><strong aria-hidden="true">12.1.</strong> 为何OO(todo)</a></li><li class="chapter-item expanded "><a href="../object-oriented/trait-object.html"><strong aria-hidden="true">12.2.</strong> 特征对象</a></li><li class="chapter-item expanded "><a href="../object-oriented/design-pattern.html"><strong aria-hidden="true">12.3.</strong> 设计模式</a></li></ol></li><li class="chapter-item expanded "><a href="../unsafe/intro.html"><strong aria-hidden="true">13.</strong> 不安全Rust todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsafe/raw-pointer.html"><strong aria-hidden="true">13.1.</strong> 原生指针(todo)</a></li><li class="chapter-item expanded "><a href="../unsafe/modify-global-var.html"><strong aria-hidden="true">13.2.</strong> 修改全局变量</a></li><li class="chapter-item expanded "><a href="../unsafe/ffi.html"><strong aria-hidden="true">13.3.</strong> FFI外部语言用</a></li><li class="chapter-item expanded "><a href="../unsafe/ub.html"><strong aria-hidden="true">13.4.</strong> 那些会导致UB的代码</a></li></ol></li><li class="chapter-item expanded "><a href="../fight-with-compiler/intro.html"><strong aria-hidden="true">14.</strong> 对抗编译检查 doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fight-with-compiler/phantom-data.html"><strong aria-hidden="true">14.1.</strong> 幽灵数据(todo)</a></li><li class="chapter-item expanded "><a href="../fight-with-compiler/lifetime/intro.html"><strong aria-hidden="true">14.2.</strong> 生命周期)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long1.html"><strong aria-hidden="true">14.2.1.</strong> 生命周期过大-01</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/too-long2.html"><strong aria-hidden="true">14.2.2.</strong> 生命周期过大-02</a></li><li class="chapter-item "><a href="../fight-with-compiler/lifetime/loop.html"><strong aria-hidden="true">14.2.3.</strong> 循环中的生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="../fight-with-compiler/unconstrained.html"><strong aria-hidden="true">14.3.</strong> 类型未限制(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../macro/intro.html"><strong aria-hidden="true">15.</strong> 宏编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../macro/procedure-macro.html"><strong aria-hidden="true">15.1.</strong> 过程宏(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../performance/intro.html"><strong aria-hidden="true">16.</strong> 性能调优 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../performance/deep-into-move.html"><strong aria-hidden="true">16.1.</strong> 深入理解move</a></li><li class="chapter-item expanded "><a href="../performance/early-optimise.html"><strong aria-hidden="true">16.2.</strong> 糟糕的提前优化</a></li><li class="chapter-item expanded "><a href="../performance/clone-copy.html"><strong aria-hidden="true">16.3.</strong> Clone和Copy</a></li><li class="chapter-item expanded "><a href="../performance/benchmark.html"><strong aria-hidden="true">16.4.</strong> Benchmark性能测试(todo)</a></li><li class="chapter-item expanded "><a href="../performance/runtime-check.html"><strong aria-hidden="true">16.5.</strong> 减少Runtime check(todo)</a></li><li class="chapter-item expanded "><a href="../performance/cpu-cache.html"><strong aria-hidden="true">16.6.</strong> CPU缓存性能优化</a></li><li class="chapter-item expanded "><a href="../performance/calculate.html"><strong aria-hidden="true">16.7.</strong> 计算性能优化</a></li><li class="chapter-item expanded "><a href="../performance/heap-stack.html"><strong aria-hidden="true">16.8.</strong> 堆和栈</a></li><li class="chapter-item expanded "><a href="../performance/tools.html"><strong aria-hidden="true">16.9.</strong> 常用性能测试工具</a></li></ol></li><li class="chapter-item expanded "><a href="../compiler/intro.html"><strong aria-hidden="true">17.</strong> 编译器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../compiler/attributes.html"><strong aria-hidden="true">17.1.</strong> 常见属性标记</a></li><li class="chapter-item expanded "><a href="../compiler/speed-up.html"><strong aria-hidden="true">17.2.</strong> 优化编译速度</a></li></ol></li><li class="chapter-item expanded "><a href="../monitor/intro.html"><strong aria-hidden="true">18.</strong> 日志和监控 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monitor/log.html"><strong aria-hidden="true">18.1.</strong> 日志</a></li><li class="chapter-item expanded "><a href="../monitor/observability.html"><strong aria-hidden="true">18.2.</strong> 可观测性</a></li><li class="chapter-item expanded "><a href="../monitor/apm.html"><strong aria-hidden="true">18.3.</strong> 监控(APM)</a></li></ol></li><li class="chapter-item expanded "><a href="../std/intro.html"><strong aria-hidden="true">19.</strong> 标准库解析 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../std/search.html"><strong aria-hidden="true">19.1.</strong> 如何寻找你想要的内容</a></li><li class="chapter-item expanded "><a href="../std/vector.html"><strong aria-hidden="true">19.2.</strong> Vector常用方法</a></li><li class="chapter-item expanded "><a href="../std/hashmap.html"><strong aria-hidden="true">19.3.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="../std/iterator.html"><strong aria-hidden="true">19.4.</strong> Iterator常用方法</a></li></ol></li><li class="chapter-item expanded "><a href="../libraries/intro.html"><strong aria-hidden="true">20.</strong> 常用三方库 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../libraries/json/intro.html"><strong aria-hidden="true">20.1.</strong> JSON</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../libraries/json/serde.html"><strong aria-hidden="true">20.1.1.</strong> serde(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../libraries/http/intro.html"><strong aria-hidden="true">20.2.</strong> HTTP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../libraries/http/reqwest.html"><strong aria-hidden="true">20.2.1.</strong> reqwest(todo)</a></li></ol></li><li class="chapter-item expanded "><a href="../libraries/command/intro.html"><strong aria-hidden="true">20.3.</strong> 命令行解析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../libraries/command/structopt.html"><strong aria-hidden="true">20.3.1.</strong> structopt(todo)</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cargo/intro.html"><strong aria-hidden="true">21.</strong> Cargo详解 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cargo/commands.html"><strong aria-hidden="true">21.1.</strong> 常用命令</a></li><li class="chapter-item expanded "><a href="../cargo/layout.html"><strong aria-hidden="true">21.2.</strong> 项目结构</a></li><li class="chapter-item expanded "><a href="../cargo/cargo-toml-lock.html"><strong aria-hidden="true">21.3.</strong> Cargo.toml和Cargo.lock</a></li><li class="chapter-item expanded "><a href="../cargo/dependency.html"><strong aria-hidden="true">21.4.</strong> 依赖管理</a></li><li class="chapter-item expanded "><a href="../cargo/cache.html"><strong aria-hidden="true">21.5.</strong> 构建缓存</a></li><li class="chapter-item expanded "><a href="../cargo/version.html"><strong aria-hidden="true">21.6.</strong> 版本管理</a></li><li class="chapter-item expanded "><a href="../cargo/workspace.html"><strong aria-hidden="true">21.7.</strong> 工作空间</a></li><li class="chapter-item expanded "><a href="../cargo/feature.html"><strong aria-hidden="true">21.8.</strong> 条件编译、条件依赖</a></li><li class="chapter-item expanded "><a href="../cargo/manifest.html"><strong aria-hidden="true">21.9.</strong> 配置参数(todo)</a></li><li class="chapter-item expanded "><a href="../cargo/build-js.html"><strong aria-hidden="true">21.10.</strong> 自定义构建脚本</a></li><li class="chapter-item expanded "><a href="../cargo/profile.html"><strong aria-hidden="true">21.11.</strong> Cargo profile</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix/intro.html"><strong aria-hidden="true">22.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendix/keywords.html"><strong aria-hidden="true">22.1.</strong> A-关键字</a></li><li class="chapter-item expanded "><a href="../appendix/operators.html"><strong aria-hidden="true">22.2.</strong> B-运算符与符号</a></li><li class="chapter-item expanded "><a href="../appendix/expressions.html"><strong aria-hidden="true">22.3.</strong> C-表达式</a></li><li class="chapter-item expanded "><a href="../appendix/derive.html"><strong aria-hidden="true">22.4.</strong> D-派生特征derive</a></li><li class="chapter-item expanded "><a href="../appendix/prelude.html"><strong aria-hidden="true">22.5.</strong> E-prelude模块 todo</a></li><li class="chapter-item expanded "><a href="../appendix/difficulties.html"><strong aria-hidden="true">22.6.</strong> F-难点索引</a></li><li class="chapter-item expanded "><a href="../appendix/rust-version.html"><strong aria-hidden="true">22.7.</strong> G-Rust版本发布</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言圣经(Rust学习教程)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-course/edit/main/book-contents/basic/method.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="方法method"><a class="header" href="#方法method">方法Method</a></h1>
<p>从面向对象语言过来的同学对于方法肯定不陌生，<code>class</code>里面就充斥着方法的概念，在Rust中方法的概念也大差不差，往往和对象成对出现:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>object.method()
<span class="boring">}
</span></code></pre></pre>
<p>例如读取一个文件写入缓冲区，如果用函数的写法<code>read(f,buffer)</code>,用方法的写法<code>f.read(buffer)</code>. 不过与其它语言<code>class</code>跟方法的联动使用不同，Rust的方法往往跟结构体、枚举、特征一起使用，特征将在后面几章进行介绍。</p>
<h2 id="定义方法"><a class="header" href="#定义方法">定义方法</a></h2>
<p>Rust使用<code>impl</code>来定义方法,例如以下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // new是Circle的关联函数，因为它的第一个参数不是self
    // 这种方法往往用于初始化当前结构体的实例
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circle的方法，&amp;self表示借用当前的Circle结构体
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们这里先不详细展开讲解，首先建立对方法定义的大致印象。下面图片将Rust方法定义与其它语言的方法定义做一下对比：</p>
<img alt="" src="/img/method-01.png" class="center"/>
<p>可以看出，其它语言中所有定义都在<code>class</code>中，但是Rust的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p>
<p>再来看一个例子：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p>该例子定义了一个<code>Rectangle</code>结构体，并且在其上定义一个<code>area</code>方法，用于计算该矩形的面积。</p>
<p><code>impl Rectangle {}</code>表示为<code>Rectangle</code>实现方法(<code>impl</code> 是实现<em>implementation</em> 的缩写)，这样的写法标明<code>impl</code>语句块中的一切都是跟<code>Rectangle</code>相关联的。</p>
<p>接下里的内容非常重要，请大家仔细看。在 <code>area</code> 的签名中，有一个我们之前没有看到过的关键字<code>&amp;self</code>，该关键字指代的是<code>&amp;Rectangle</code>类型，换句话说，<code>self</code>指代的是<code>Rectangle</code>结构体，这样的写法会让我们的代码简洁很多，而且非常便于理解: 我们为哪个结构体实现方法，那么<code>self</code>就是指代的该结构体自身。</p>
<p>需要注意的是，<code>self</code>依然有所有权的概念：</p>
<ul>
<li><code>self</code>表示<code>Rectangle</code>的所有权转移到该方法中，这种形式用的较少</li>
<li><code>&amp;self</code>表示该方法对<code>Rectangle</code>的不可变借用</li>
<li><code>&amp;mut self</code>表示可变借用</li>
</ul>
<p>总之，<code>self</code>的使用就跟函数参数一样，要严格遵守Rust的所有权规则。</p>
<p>回到上面的例子中，选择 <code>&amp;self</code> 的理由跟在函数中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，也无需去改变它，只是希望能够读取结构体中的数据。如果想要在方法中去改变当前的结构体，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的，这种使用方式往往用于把当前的对象转成另外一个对象时使用，转换完后，就不再关注之前的对象，且可以防止对之前对象的误调用。</p>
<p>简单总结下，使用方法代替函数有以下好处：</p>
<ul>
<li>不用在函数签名中重复书写<code>self</code>对应的类型</li>
<li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li>
</ul>
<h4 id="方法名跟结构体字段名相同"><a class="header" href="#方法名跟结构体字段名相同">方法名跟结构体字段名相同</a></h4>
<p>在Rust中，允许方法名跟结构体的字段名相同：</p>
<pre><pre class="playground"><code class="language-rust">impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>当我们使用<code>rect1.width()</code>时，Rust知道我们调用的是它的方法，如果使用<code>rect1.witdh</code>，则是调用它的字段。</p>
<p>一般来说，方法跟字段同名，往往适用于实现<code>getter</code>访问器，例如:</p>
<pre><pre class="playground"><code class="language-rust">pub struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    pub fn new(width: u32, height: u32) -&gt; Self {
        Rectangle { width, height }
    }
    pub fn width(&amp;self) -&gt; u32 {
        return self.width;
    }
}

fn main() {
    let rect1 = Rectangle::new(30, 50);

    println!(&quot;{}&quot;, rect1.width());
}
</code></pre></pre>
<p>用这种方式，我们可以把<code>Rectangle</code>的字段设置为私有属性，只需把它的<code>new</code>和<code>witdh</code>方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器<code>rect1.width()</code>方法来获取矩形的宽度, 因为<code>width</code>字段是私有的，当用户访问<code>rect1.witdh</code>字段时，就会报错。</p>
<blockquote>
<h3 id="--运算符到哪去了"><a class="header" href="#--运算符到哪去了"><code>-&gt;</code> 运算符到哪去了？</a></h3>
<p>在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code>和<code>(*object).something()</code>是一样的。</p>
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</blockquote>
<h2 id="带有多个参数的方法"><a class="header" href="#带有多个参数的方法">带有多个参数的方法</a></h2>
<p>方法和函数一样，可以使用多个参数:</p>
<pre><pre class="playground"><code class="language-rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre></pre>
<h2 id="关联函数"><a class="header" href="#关联函数">关联函数</a></h2>
<p>现在大家可以思考一个问题，如果为一个结构体定义一个构造器方法？也就是接受几个参数，然后构造并返回该结构体的实例。其实答案在开头的代码片段中就给出了，很简单，不使用<code>self</code>中即可。</p>
<p>这种定义在<code>impl</code>中且没有<code>self</code>的函数被称之为<strong>关联函数</strong>： 因为它没有<code>self</code>，不能用<code>f.read()</code>的形式使用，因此它是一个函数而不是方法，它又在<code>impl</code>中,与结构体紧密关联，因此称为关联函数。</p>
<p>在之前的代码中，我们已经多次使用过关联函数，例如<code>String::from</code>,用于创建一个动态字符串。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn new(w: u32, h: u32) -&gt; Rectangle {
        Rectangle { width: w, height: h }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust中有一个约定俗称的规则，使用<code>new</code>来作为构造器的名称，出于设计上的考虑，Rust特地没有用<code>new</code>作为关键字</p>
</blockquote>
<p>因为是函数，所以不能用<code>.</code>的方式来调用，我们需要用<code>::</code>来调用，例如 <code>let sq = Rectangle::new(3,3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p>
<h2 id="多个impl定义"><a class="header" href="#多个impl定义">多个impl定义</a></h2>
<p>Rust允许我们为一个结构体定义多个<code>impl</code>块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同个<code>impl</code>块中，那么就可以形成多个<code>impl</code>块，各自完成一块儿目标：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，就这个例子而言，我们没必要使用两个<code>impl</code>块，这里只是为了演示方便。</p>
<h2 id="为枚举实现方法"><a class="header" href="#为枚举实现方法">为枚举实现方法</a></h2>
<p>枚举类型之所以强大，不仅仅在于它好用、可以<a href="./compound-type/enum.html#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B">同一化类型</a>，还在于，我们可以像结构体一样，为枚举实现方法:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // 在这里定义方法体
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
}
</code></pre></pre>
<p>除了结构体和枚举，我们还能为特征(trait)实现方法，将在下下章进行讲解，在此之前，先来看看泛型。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basic/match-pattern/all-patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basic/trait/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basic/match-pattern/all-patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basic/trait/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/ferris.js"></script>


    </body>
</html>
